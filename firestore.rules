rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // User profiles
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Monitored Sources
    // Limit validation logic should ideally be in Functions or enforced via specific rule limits, 
    // but for MVP CRUD, we'll allow Authenticated owners to write.
    match /sources/{sourceId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      // CREATE is now disallowed from client. Must use Callable Function 'createSource'.
      // Allow update for owners, but restrict to Phase 3 hardening fields
      allow update: if request.auth != null && resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'verifiedAt', 'verifiedBy', 'verifiedReason', 'verifiedNote', 'verifiedHash', 'verifiedFingerprint',
          'status', 'pausedAt', 'pausedBy', 'pauseReason', 'nextCheckAt', 'consecutiveFailures', 'needsCheck', 'lastStatus', 'lastVerifiedAt',
          'alertThreshold', 'alertMode'
        ]);
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Change Logs
    match /changes/{changeId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      // Only backend (Functions) should write changes, but we might allow read-only for client
      // We will allow no public writes. Admin SDK bypasses rules.
    }

    // Audit Logs
    match /audit_logs/{logId} {
      allow read, create: if request.auth != null && request.auth.uid == request.resource.data.userId;
    }
  }
}
